/**
 * SpellTreeRenderer Module - Clean Canvas 2D renderer for universal coordinates
 *
 * Reads pre-baked x,y positions from spell_tree.json (generated by scan page Apply).
 * No layout engine — positions come from data. Fallback spiral for positionless nodes.
 *
 * Features:
 *   - Tier-differentiated nodes via TierVisuals (circle/diamond/star by skillLevel)
 *   - Node states: locked (dim), available (bright), learning (cyan), unlocked (full)
 *   - 3-pass edge rendering (base → selected path → learning path)
 *   - Pan/zoom with mouse wheel zoom-to-cursor
 *   - Spatial index for fast hit detection
 *   - Discovery mode (fog of war)
 *   - Learning path animation with pulse particles
 *   - Heartbeat hub at center
 *   - Tooltip on hover, detail panel on click
 *   - EditMode compatible API surface
 *
 * Depends on: TierVisuals, settings (global), state (global)
 * Optional: Starfield, Globe3D, EditMode
 */

var SpellTreeRenderer = {

    // =========================================================================
    // CANVAS + DPR
    // =========================================================================

    canvas: null,
    ctx: null,
    container: null,
    _width: 0,
    _height: 0,
    _dpr: 1,

    // =========================================================================
    // DATA
    // =========================================================================

    nodes: [],
    edges: [],
    schools: {},
    _nodeMap: null,       // id → node
    _nodeByFormId: null,  // formId → node

    // =========================================================================
    // TRANSFORM
    // =========================================================================

    zoom: 1,
    panX: 0,
    panY: 0,

    // =========================================================================
    // INTERACTION
    // =========================================================================

    isPanning: false,
    panStartX: 0,
    panStartY: 0,
    selectedNode: null,
    hoveredNode: null,
    _pendingPanX: 0,
    _pendingPanY: 0,
    _panRafPending: false,

    // =========================================================================
    // SPATIAL INDEX
    // =========================================================================

    _nodeGrid: null,
    _gridCellSize: 50,

    // =========================================================================
    // RENDER LOOP
    // =========================================================================

    _rafId: null,
    _needsRender: true,
    _animationOnlyRender: false,
    _lastRenderTime: 0,
    _logNextRender: false,

    // =========================================================================
    // DISCOVERY MODE
    // =========================================================================

    _discoveryVisibleIds: null,

    // =========================================================================
    // SELECTED PATH
    // =========================================================================

    _selectedPathEdges: null,
    _selectedPathNodes: null,

    // =========================================================================
    // HEARTBEAT HUB
    // =========================================================================

    _heartbeatPhase: 0,
    _heartbeatSpeed: 0.2,
    _heartPulseDelay: 5.0,
    _heartAnimationEnabled: true,
    _heartBgOpacity: 1.0,
    _heartBgColor: '#000000',
    _bgColor: '#000000',
    _heartRingColor: '#b8a878',
    _globeText: 'HoM',
    _globeTextSize: 16,
    _magicTextColor: null,
    _globeEnabled: true,
    _globeColor: null,

    // =========================================================================
    // LEARNING PATH
    // =========================================================================

    _learningPathColor: '#00ffff',
    _learningPath: null,
    _learningPathDuration: 1200,
    _learningPathAnimationComplete: true,
    _animatingPathNodes: null,
    _learningNodeIds: null,
    _learningPathNodes: null,
    _learningPulses: [],
    _lastHeartbeatPulse: false,
    _learningPathSegments: [],
    _learningPulseSpeed: 0.015,
    _learningPulseSize: 4,

    // =========================================================================
    // STARFIELD
    // =========================================================================

    _starfieldEnabled: true,
    _starfieldFixed: true,
    _starfieldColor: '#ffffff',
    _starfieldDensity: 200,
    _starfieldMaxSize: 2.5,

    // =========================================================================
    // SCHOOL COLORS (defaults — overridden by settings if available)
    // =========================================================================

    _schoolColors: {
        'Destruction': '#ff4444',
        'Restoration': '#ffdd44',
        'Alteration':  '#44ff44',
        'Conjuration': '#4488ff',
        'Illusion':    '#aa44ff'
    },

    // =========================================================================
    // TOOLTIP
    // =========================================================================

    _tooltipEl: null,

    // =========================================================================
    // DEBUG
    // =========================================================================

    showDebugGrid: false,

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    init: function(container) {
        this.container = container;

        if (!this.canvas) {
            this.canvas = document.createElement('canvas');
            this.canvas.id = 'tree-canvas';
            this.canvas.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 1;';
            this.ctx = this.canvas.getContext('2d');
            this._setupEvents();
        }

        console.log('[SpellTreeRenderer] Initialized');
        return this;
    },

    updateCanvasSize: function() {
        if (!this.container || !this.canvas) return;

        var rect = this.container.getBoundingClientRect();
        var width = rect.width || 800;
        var height = rect.height || 600;
        var dpr = window.devicePixelRatio || 1;

        this.canvas.width = width * dpr;
        this.canvas.height = height * dpr;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';

        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);

        this._width = width;
        this._height = height;
        this._dpr = dpr;
        this._needsRender = true;
    },

    destroy: function() {
        this.stopRenderLoop();
        if (this._resizeObserver) {
            this._resizeObserver.disconnect();
            this._resizeObserver = null;
        }
        if (this._resizeTimeout) {
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = null;
        }
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        this._hideTooltip();
        console.log('[SpellTreeRenderer] Destroyed');
    },

    // =========================================================================
    // EVENT SETUP
    // =========================================================================

    _setupEvents: function() {
        var self = this;

        // Use public method names (onMouseDown, not _onMouseDown) so EditMode
        // can replace them via CanvasRenderer.onMouseDown = function(...) { ... }
        this.canvas.addEventListener('mousedown', function(e) { self.onMouseDown(e); });
        this.canvas.addEventListener('mousemove', function(e) { self.onMouseMove(e); });
        this.canvas.addEventListener('mouseup', function(e) { self.onMouseUp(e); });
        this.canvas.addEventListener('mouseleave', function(e) { self.onMouseUp(e); });
        this.canvas.addEventListener('wheel', function(e) {
            e.preventDefault();
            self._onWheel(e);
        }, { passive: false });
        this.canvas.addEventListener('click', function(e) { self.onClick(e); });

        window.addEventListener('resize', function() { self.updateCanvasSize(); });

        if (typeof ResizeObserver !== 'undefined' && this.container) {
            this._resizeObserver = new ResizeObserver(function() {
                if (self._resizeTimeout) clearTimeout(self._resizeTimeout);
                self._resizeTimeout = setTimeout(function() { self.updateCanvasSize(); }, 50);
            });
            this._resizeObserver.observe(this.container);
        }
    },

    // =========================================================================
    // DATA MANAGEMENT
    // =========================================================================

    setData: function(nodes, edges, schools) {
        this.selectedNode = null;
        this.hoveredNode = null;

        this.nodes = nodes || [];
        this.edges = edges || [];
        this.schools = schools || {};

        // Check if nodes need fallback layout
        var nodesWithPos = 0;
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].x !== 0 || this.nodes[i].y !== 0) nodesWithPos++;
        }
        if (this.nodes.length > 0 && nodesWithPos < this.nodes.length * 0.1) {
            console.log('[SpellTreeRenderer] <10% nodes have positions, applying fallback spiral');
            this._applyFallbackSpiral();
        }

        // Build lookup maps
        this._nodeMap = new Map();
        this._nodeByFormId = new Map();
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            this._nodeMap.set(node.id, node);
            if (node.formId) {
                this._nodeByFormId.set(node.formId, node);
                this._nodeMap.set(node.formId, node);
            }
        }

        this.buildSpatialIndex();
        this._computeSchoolAngles();
        this._buildDiscoveryVisibility();
        this._buildLearningPaths();

        this._needsRender = true;
        this._logNextRender = true;

        console.log('[SpellTreeRenderer] Data set:', this.nodes.length, 'nodes,', this.edges.length, 'edges');
    },

    // =========================================================================
    // SCHOOL COLOR LOOKUP (no TREE_CONFIG dependency)
    // =========================================================================

    _getSchoolColor: function(school) {
        if (typeof settings !== 'undefined' && settings.schoolColors && settings.schoolColors[school]) {
            return settings.schoolColors[school];
        }
        return this._schoolColors[school] || '#888888';
    },

    // =========================================================================
    // SCHOOL ANGLES (data-driven from node positions)
    // =========================================================================

    _computeSchoolAngles: function() {
        var schoolNames = Object.keys(this.schools);
        if (schoolNames.length === 0) return;

        var self = this;
        var numSchools = schoolNames.length;
        var sliceAngle = 360 / numSchools;

        for (var si = 0; si < schoolNames.length; si++) {
            var name = schoolNames[si];
            var school = self.schools[name];

            if (school.spokeAngle !== undefined && school.startAngle !== undefined) continue;

            // Find root nodes for this school
            var rootNodes = [];
            var schoolNodes = [];
            for (var ni = 0; ni < self.nodes.length; ni++) {
                var n = self.nodes[ni];
                if (n.school === name) {
                    schoolNodes.push(n);
                    if (n.isRoot) rootNodes.push(n);
                }
            }

            // Fallback: node closest to center
            if (rootNodes.length === 0 && schoolNodes.length > 0) {
                var closest = schoolNodes[0];
                var closestDist = closest.x * closest.x + closest.y * closest.y;
                for (var ci = 1; ci < schoolNodes.length; ci++) {
                    var d = schoolNodes[ci].x * schoolNodes[ci].x + schoolNodes[ci].y * schoolNodes[ci].y;
                    if (d < closestDist) { closest = schoolNodes[ci]; closestDist = d; }
                }
                rootNodes = [closest];
            }

            if (rootNodes.length > 0) {
                var sumSin = 0, sumCos = 0;
                for (var ri = 0; ri < rootNodes.length; ri++) {
                    var a = Math.atan2(rootNodes[ri].y, rootNodes[ri].x);
                    sumSin += Math.sin(a);
                    sumCos += Math.cos(a);
                }
                var avgAngle = Math.atan2(sumSin, sumCos) * 180 / Math.PI;
                school.spokeAngle = avgAngle;
                school.startAngle = avgAngle - sliceAngle / 2;
                school.endAngle = avgAngle + sliceAngle / 2;
                school.angleSpan = sliceAngle;
            } else {
                var startAngle = si * sliceAngle - 90;
                school.startAngle = startAngle;
                school.endAngle = startAngle + sliceAngle;
                school.angleSpan = sliceAngle;
                school.spokeAngle = startAngle + sliceAngle / 2;
            }
        }
    },

    // =========================================================================
    // SPATIAL INDEX
    // =========================================================================

    buildSpatialIndex: function() {
        this._nodeGrid = {};
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            var cellX = Math.floor(node.x / this._gridCellSize);
            var cellY = Math.floor(node.y / this._gridCellSize);
            var key = cellX + ',' + cellY;
            if (!this._nodeGrid[key]) this._nodeGrid[key] = [];
            this._nodeGrid[key].push(node);
        }
    },

    // =========================================================================
    // COORDINATE TRANSFORMS
    // =========================================================================

    screenToWorld: function(screenX, screenY) {
        var cx = this._width / 2;
        var cy = this._height / 2;
        return {
            x: (screenX - cx - this.panX) / this.zoom,
            y: (screenY - cy - this.panY) / this.zoom
        };
    },

    worldToScreen: function(worldX, worldY) {
        var cx = this._width / 2;
        var cy = this._height / 2;
        return {
            x: worldX * this.zoom + this.panX + cx,
            y: worldY * this.zoom + this.panY + cy
        };
    },

    findNodeAt: function(worldX, worldY) {
        var cellX = Math.floor(worldX / this._gridCellSize);
        var cellY = Math.floor(worldY / this._gridCellSize);

        for (var dx = -1; dx <= 1; dx++) {
            for (var dy = -1; dy <= 1; dy++) {
                var key = (cellX + dx) + ',' + (cellY + dy);
                var cell = this._nodeGrid[key];
                if (!cell) continue;

                for (var i = 0; i < cell.length; i++) {
                    var node = cell[i];
                    var dist = Math.sqrt(Math.pow(node.x - worldX, 2) + Math.pow(node.y - worldY, 2));
                    var hitRadius = node.state === 'unlocked' ? 14 : 10;
                    if (dist <= hitRadius) return node;
                }
            }
        }
        return null;
    },

    // =========================================================================
    // EVENT HANDLERS
    // =========================================================================

    onMouseDown: function(e) {
        if (e.button === 0 || e.button === 2) {
            this.isPanning = true;
            this.panStartX = e.clientX - this.panX;
            this.panStartY = e.clientY - this.panY;
            this.canvas.style.cursor = 'grabbing';
            this._needsRender = true;
        }
    },

    onMouseMove: function(e) {
        if (this.isPanning) {
            this._pendingPanX = e.clientX - this.panStartX;
            this._pendingPanY = e.clientY - this.panStartY;

            if (!this._panRafPending) {
                this._panRafPending = true;
                var self = this;
                requestAnimationFrame(function() {
                    self._panRafPending = false;
                    self.panX = self._pendingPanX;
                    self.panY = self._pendingPanY;
                    self._needsRender = true;
                });
            }
        } else {
            var rect = this.canvas.getBoundingClientRect();
            var world = this.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
            var node = this.findNodeAt(world.x, world.y);

            if (node !== this.hoveredNode) {
                this.hoveredNode = node;
                this.canvas.style.cursor = node ? 'pointer' : 'grab';
                this._needsRender = true;

                if (node) {
                    this._showTooltip(node, e);
                } else {
                    this._hideTooltip();
                }
            }
        }
    },

    onMouseUp: function(e) {
        this.isPanning = false;
        this.canvas.style.cursor = this.hoveredNode ? 'pointer' : 'grab';
        this._needsRender = true;
    },

    _onWheel: function(e) {
        var zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
        var newZoom = Math.max(0.1, Math.min(5, this.zoom * zoomFactor));

        var rect = this.canvas.getBoundingClientRect();
        var mouseX = e.clientX - rect.left - rect.width / 2;
        var mouseY = e.clientY - rect.top - rect.height / 2;

        this.panX = mouseX - (mouseX - this.panX) * (newZoom / this.zoom);
        this.panY = mouseY - (mouseY - this.panY) * (newZoom / this.zoom);
        this.zoom = newZoom;
        this._needsRender = true;

        var zoomEl = document.getElementById('zoom-level');
        if (zoomEl) zoomEl.textContent = Math.round(this.zoom * 100) + '%';
    },

    onClick: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var world = this.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        var clickedNode = this.findNodeAt(world.x, world.y);

        if (clickedNode) {
            this.selectedNode = clickedNode;
            this._buildSelectedPathToRoot(clickedNode);
            this._needsRender = true;
            console.log('[SpellTreeRenderer] Node clicked:', clickedNode.name || clickedNode.id);

            // Dispatch events for external handlers (detail panel, etc.)
            if (typeof CustomEvent !== 'undefined') {
                this.canvas.dispatchEvent(new CustomEvent('nodeclick', { detail: clickedNode }));
                // Also dispatch on window for WheelRenderer-compatible listeners
                window.dispatchEvent(new CustomEvent('nodeSelected', { detail: clickedNode }));
            }
        } else {
            if (this.selectedNode) {
                this.selectedNode = null;
                this._selectedPathEdges = null;
                this._selectedPathNodes = null;
                this._needsRender = true;
            }
        }
    },

    // =========================================================================
    // SELECTED PATH (bidirectional BFS)
    // =========================================================================

    _buildSelectedPathToRoot: function(node) {
        this._selectedPathEdges = new Set();
        this._selectedPathNodes = new Set();
        if (!node || !this._nodeMap) return;

        this._selectedPathNodes.add(node.id);

        // Trace back to root via prerequisites
        var visitedBack = new Set();
        var queueBack = [node.id];
        while (queueBack.length > 0) {
            var currentId = queueBack.shift();
            if (visitedBack.has(currentId)) continue;
            visitedBack.add(currentId);
            var currentNode = this._nodeMap.get(currentId);
            if (!currentNode) continue;
            this._selectedPathNodes.add(currentId);
            var prereqs = currentNode.prerequisites || [];
            for (var i = 0; i < prereqs.length; i++) {
                this._selectedPathEdges.add(prereqs[i] + '->' + currentId);
                if (!visitedBack.has(prereqs[i])) queueBack.push(prereqs[i]);
            }
        }

        // Trace forward to leaves via children
        var visitedFwd = new Set();
        var queueFwd = [node.id];
        while (queueFwd.length > 0) {
            var currentId = queueFwd.shift();
            if (visitedFwd.has(currentId)) continue;
            visitedFwd.add(currentId);
            var currentNode = this._nodeMap.get(currentId);
            if (!currentNode) continue;
            this._selectedPathNodes.add(currentId);
            var children = currentNode.children || [];
            for (var i = 0; i < children.length; i++) {
                this._selectedPathEdges.add(currentId + '->' + children[i]);
                if (!visitedFwd.has(children[i])) queueFwd.push(children[i]);
            }
        }
    },

    // =========================================================================
    // DISCOVERY MODE
    // =========================================================================

    _buildDiscoveryVisibility: function() {
        if (typeof settings === 'undefined' || !settings.discoveryMode || settings.cheatMode) {
            this._discoveryVisibleIds = null;
            return;
        }

        var visible = new Set();
        var availableOrUnlocked = new Set();

        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            if (node.state === 'unlocked' || node.state === 'learning' || node.state === 'available') {
                visible.add(node.id);
                if (node.formId) visible.add(node.formId);
                availableOrUnlocked.add(node.id);
                if (node.formId) availableOrUnlocked.add(node.formId);
            }
        }

        // One step beyond visible
        for (var i = 0; i < this.edges.length; i++) {
            var edge = this.edges[i];
            if (availableOrUnlocked.has(edge.from) && !availableOrUnlocked.has(edge.to)) {
                visible.add(edge.to);
            }
            if (availableOrUnlocked.has(edge.to) && !availableOrUnlocked.has(edge.from)) {
                visible.add(edge.from);
            }
        }

        this._discoveryVisibleIds = visible;
    },

    setDiscoveryVisible: function(nodeIds) {
        if (!nodeIds) { this._discoveryVisibleIds = null; return; }
        this._discoveryVisibleIds = new Set(nodeIds);
        this._needsRender = true;
    },

    // =========================================================================
    // LEARNING PATHS (persistent state tracking)
    // =========================================================================

    _buildLearningPaths: function() {
        if (typeof Globe3D !== 'undefined' && Globe3D.clearDetachedParticles) {
            Globe3D.clearDetachedParticles();
        }

        this._learningNodeIds = new Set();
        this._learningPathNodes = new Set();
        this._learningPathSegments = [];
        this._learningPulses = [];

        if (!this.nodes || this.nodes.length === 0) return;

        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            if ((node.state || '').toLowerCase() === 'learning') {
                this._learningNodeIds.add(node.id);
                var pathNodes = this._getPathToRoot(node.id);
                for (var j = 0; j < pathNodes.length; j++) {
                    this._learningPathNodes.add(pathNodes[j]);
                }
            }
        }
    },

    _getPathToRoot: function(nodeId) {
        var path = [nodeId];
        var visited = new Set([nodeId]);
        var current = nodeId;
        var safety = 100;

        var startNode = this._nodeMap ? this._nodeMap.get(nodeId) : null;
        if (startNode && (startNode.isRoot || startNode.tier === 1)) return path;

        while (safety-- > 0) {
            var prereqId = null;
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                if (edge.to === current && !visited.has(edge.from)) {
                    prereqId = edge.from;
                    break;
                }
            }
            if (!prereqId) break;
            path.push(prereqId);
            visited.add(prereqId);
            current = prereqId;
            var currentNode = this._nodeMap ? this._nodeMap.get(current) : null;
            if (currentNode && (currentNode.isRoot || currentNode.tier === 1)) break;
        }
        return path;
    },

    setLearningNode: function(nodeId) {
        this.triggerLearningAnimation(nodeId);
    },

    triggerLearningAnimation: function(nodeId) {
        var node = this._nodeMap ? this._nodeMap.get(nodeId) : null;
        if (!node) return;

        var path = this._buildPathToNode(nodeId);
        if (path.length < 2) return;

        this._learningPath = {
            nodeId: nodeId,
            path: path,
            progress: 0,
            startTime: performance.now(),
            color: this._learningPathColor
        };

        this._animatingPathNodes = new Set();
        for (var i = 0; i < path.length; i++) {
            if (path[i].node && path[i].node.id) this._animatingPathNodes.add(path[i].node.id);
        }
        this._learningPathAnimationComplete = false;
        this._needsRender = true;
    },

    _buildPathToNode: function(nodeId) {
        var path = [];
        var visited = new Set();
        var node = this._nodeMap.get(nodeId);
        if (!node) return path;

        var current = node;
        var safety = 100;
        while (current && safety-- > 0) {
            path.unshift({ x: current.x, y: current.y, node: current });
            visited.add(current.id);
            var prereq = null;
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                if (edge.to === current.id && !visited.has(edge.from)) {
                    prereq = this._nodeMap.get(edge.from);
                    break;
                }
            }
            if (!prereq) break;
            current = prereq;
        }
        path.unshift({ x: 0, y: 0, node: null });
        return path;
    },

    _buildLearningPathSegments: function() {
        this._learningPathSegments = [];
        if (!this._learningNodeIds || this._learningNodeIds.size === 0) return;
        if (!this._nodeMap) return;

        var self = this;
        this._learningNodeIds.forEach(function(learningId) {
            var pathNodeIds = self._getPathToRoot(learningId);
            if (pathNodeIds.length === 0) return;
            pathNodeIds.reverse();

            var segments = [];
            var rootNode = self._nodeMap.get(pathNodeIds[0]);
            if (rootNode) {
                segments.push({ from: { x: 0, y: 0 }, to: { x: rootNode.x, y: rootNode.y } });
            }
            for (var i = 0; i < pathNodeIds.length - 1; i++) {
                var fromNode = self._nodeMap.get(pathNodeIds[i]);
                var toNode = self._nodeMap.get(pathNodeIds[i + 1]);
                if (fromNode && toNode) {
                    segments.push({ from: { x: fromNode.x, y: fromNode.y }, to: { x: toNode.x, y: toNode.y } });
                }
            }
            if (segments.length > 0) {
                self._learningPathSegments.push({
                    learningNodeId: learningId,
                    segments: segments,
                    totalLength: self._calculatePathLength(segments)
                });
            }
        });
    },

    _calculatePathLength: function(segments) {
        var total = 0;
        for (var i = 0; i < segments.length; i++) {
            var dx = segments[i].to.x - segments[i].from.x;
            var dy = segments[i].to.y - segments[i].from.y;
            total += Math.sqrt(dx * dx + dy * dy);
        }
        return total;
    },

    _getPositionAlongPath: function(segments, progress) {
        if (!segments || segments.length === 0) return null;
        var totalLen = this._calculatePathLength(segments);
        var targetLen = totalLen * progress;
        var accumulated = 0;

        for (var i = 0; i < segments.length; i++) {
            var seg = segments[i];
            var dx = seg.to.x - seg.from.x;
            var dy = seg.to.y - seg.from.y;
            var segLen = Math.sqrt(dx * dx + dy * dy);

            if (accumulated + segLen >= targetLen) {
                var t = (targetLen - accumulated) / segLen;
                return { x: seg.from.x + dx * t, y: seg.from.y + dy * t };
            }
            accumulated += segLen;
        }
        var last = segments[segments.length - 1];
        return { x: last.to.x, y: last.to.y };
    },

    _detachGlobeParticleToLearningPath: function() {
        if (typeof Globe3D === 'undefined' || !Globe3D.enabled) return;
        if (!this._learningPathSegments || this._learningPathSegments.length === 0) {
            this._buildLearningPathSegments();
        }
        if (!this._learningPathSegments || this._learningPathSegments.length === 0) return;
        var learningColor = this._learningPathColor || '#00ffff';
        for (var i = 0; i < this._learningPathSegments.length; i++) {
            Globe3D.detachParticleToPath(this._learningPathSegments[i].segments, this._learningPulseSpeed, learningColor);
        }
    },

    // =========================================================================
    // RENDER LOOP
    // =========================================================================

    startRenderLoop: function() {
        if (this._rafId) return;
        var self = this;
        var lastAnimationRender = 0;
        var animationThrottleMs = 50;

        function loop(timestamp) {
            var shouldRender = self._needsRender;
            if (shouldRender && self._animationOnlyRender) {
                if (timestamp - lastAnimationRender < animationThrottleMs) {
                    shouldRender = false;
                } else {
                    lastAnimationRender = timestamp;
                }
            }
            if (shouldRender) {
                self._needsRender = false;
                self._animationOnlyRender = false;
                self._render();
            }
            self._rafId = requestAnimationFrame(loop);
        }
        loop(performance.now());
    },

    stopRenderLoop: function() {
        if (this._rafId) {
            cancelAnimationFrame(this._rafId);
            this._rafId = null;
        }
    },

    forceRender: function() {
        this._needsRender = true;
        this._render();
    },

    // =========================================================================
    // MAIN RENDER
    // =========================================================================

    _render: function() {
        if (!this.ctx || !this.canvas) return;

        var startTime = performance.now();
        var ctx = this.ctx;
        var width = this._width || 800;
        var height = this._height || 600;
        if (width === 0 || height === 0) return;

        var cx = width / 2;
        var cy = height / 2;
        var dpr = this._dpr || 1;

        // Full reset
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1.0;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = this._bgColor || '#000000';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.scale(dpr, dpr);

        // 1. Starfield (screen-space, behind everything)
        this._renderStarfield(ctx);

        // Calculate view bounds for culling
        var viewExtent = Math.max(cx, cy) / this.zoom + 500;
        var viewCenterX = -this.panX / this.zoom;
        var viewCenterY = -this.panY / this.zoom;
        var viewLeft = viewCenterX - viewExtent;
        var viewRight = viewCenterX + viewExtent;
        var viewTop = viewCenterY - viewExtent;
        var viewBottom = viewCenterY + viewExtent;

        // 2. World-space rendering (pan + zoom)
        ctx.save();
        ctx.translate(cx + this.panX, cy + this.panY);
        ctx.scale(this.zoom, this.zoom);

        // School dividers
        this._renderSchoolDividers(ctx);

        // Edges (3-pass)
        this._renderEdges(ctx, viewLeft, viewRight, viewTop, viewBottom);

        // Learning path animation
        this._renderLearningPathAnimation(ctx);

        // Detached globe particles
        if (typeof Globe3D !== 'undefined' && Globe3D.detachedParticles && Globe3D.detachedParticles.length > 0) {
            Globe3D._renderDetachedParticles(ctx);
        }

        // Nodes
        this._renderNodes(ctx, viewLeft, viewRight, viewTop, viewBottom);

        // Edit mode overlay
        if (typeof EditMode !== 'undefined' && EditMode.isActive) {
            EditMode.renderOverlay(ctx);
        }

        ctx.restore();

        // 3. Center hub (heartbeat, does NOT move with pan/zoom... wait, it should move with pan/zoom but not rotate)
        ctx.save();
        ctx.translate(cx + this.panX, cy + this.panY);
        ctx.scale(this.zoom, this.zoom);
        this._renderHub(ctx);
        ctx.restore();

        // 4. Labels (screen-aligned)
        this._renderLabels(ctx, cx, cy);

        var elapsed = performance.now() - startTime;
        if (elapsed > 16 || this._logNextRender) {
            console.log('[SpellTreeRenderer] Render:', Math.round(elapsed) + 'ms,', this.nodes.length, 'nodes');
            this._logNextRender = false;
        }
    },

    // =========================================================================
    // STARFIELD
    // =========================================================================

    _renderStarfield: function(ctx) {
        if (!this._starfieldEnabled || typeof Starfield === 'undefined') return;

        Starfield.setColor(this._starfieldColor || '#ffffff');
        if (Starfield.starCount !== this._starfieldDensity) {
            Starfield.starCount = this._starfieldDensity || 200;
            Starfield.stars = null;
        }
        Starfield.maxSize = this._starfieldMaxSize || 2.5;

        if (!Starfield.stars || Starfield.width !== this._width || Starfield.height !== this._height) {
            Starfield.init(this._width, this._height);
        }

        if (this._starfieldFixed) {
            Starfield.render(ctx);
        } else {
            ctx.save();
            ctx.translate(this.panX, this.panY);
            ctx.scale(this.zoom, this.zoom);
            Starfield.render(ctx);
            ctx.restore();
        }
        this._needsRender = true;
        this._animationOnlyRender = true;
    },

    // =========================================================================
    // SCHOOL DIVIDERS
    // =========================================================================

    _renderSchoolDividers: function(ctx) {
        if (typeof settings === 'undefined' || !settings.showSchoolDividers) return;

        var schoolNames = Object.keys(this.schools);
        if (schoolNames.length < 2) return;

        var length = settings.dividerLength !== undefined ? settings.dividerLength : 800;
        var fade = (settings.dividerFade !== undefined ? settings.dividerFade : 50) / 100;
        var lineWidth = settings.dividerSpacing !== undefined ? settings.dividerSpacing : 3;
        var colorMode = settings.dividerColorMode || 'school';
        var customColor = settings.dividerCustomColor || '#ffffff';

        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'round';

        for (var i = 0; i < schoolNames.length; i++) {
            var schoolName = schoolNames[i];
            var school = this.schools[schoolName];
            var angle = school.startAngle !== undefined ? school.startAngle : (i * (360 / schoolNames.length) - 90);
            var rad = angle * Math.PI / 180;

            var color = colorMode === 'custom' ? customColor : this._getSchoolColor(schoolName);
            var endX = Math.cos(rad) * length;
            var endY = Math.sin(rad) * length;
            var gradient = ctx.createLinearGradient(0, 0, endX, endY);

            var rgb = TierVisuals._hexToRgb(color);
            var startAlpha = 0.8;
            var endAlpha = startAlpha * (1 - fade);

            gradient.addColorStop(0, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + startAlpha + ')');
            gradient.addColorStop(0.5, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + (startAlpha * 0.7 + endAlpha * 0.3) + ')');
            gradient.addColorStop(1, 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + endAlpha + ')');

            ctx.strokeStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }
    },

    // =========================================================================
    // EDGE RENDERING (3-pass)
    // =========================================================================

    _renderEdges: function(ctx, viewLeft, viewRight, viewTop, viewBottom) {
        var learningPathColor = this._learningPathColor || '#00ffff';
        var hasLearningPaths = this._learningPathNodes instanceof Set && this._learningPathNodes.size > 0;

        // Heartbeat pulse spawning
        if (hasLearningPaths && this._heartAnimationEnabled) {
            var phasePerSecond = this._heartbeatSpeed * 60;
            var pulseDelay = (this._heartPulseDelay || 2.0) * phasePerSecond;
            var beatDuration = Math.PI;
            var cycleLength = beatDuration + pulseDelay;
            var cyclePos = this._heartbeatPhase % cycleLength;
            var nowBeating = cyclePos < beatDuration && cyclePos < 0.5;
            if (nowBeating && !this._lastHeartbeatPulse) {
                this._detachGlobeParticleToLearningPath();
            }
            this._lastHeartbeatPulse = nowBeating;
        }

        var self = this;
        var hasSelectedPath = this._selectedPathEdges && this._selectedPathEdges.size > 0;

        function shouldDrawEdge(edge) {
            var fromNode = self._nodeMap.get(edge.from);
            var toNode = self._nodeMap.get(edge.to);
            if (!fromNode || !toNode) return null;

            // Discovery mode filter
            if (self._discoveryVisibleIds && !(typeof EditMode !== 'undefined' && EditMode.isActive)) {
                var fv = self._discoveryVisibleIds.has(edge.from) || self._discoveryVisibleIds.has(fromNode.id);
                var tv = self._discoveryVisibleIds.has(edge.to) || self._discoveryVisibleIds.has(toNode.id);
                if (!fv || !tv) return null;
            }

            // Viewport culling
            var minX = Math.min(fromNode.x, toNode.x);
            var maxX = Math.max(fromNode.x, toNode.x);
            var minY = Math.min(fromNode.y, toNode.y);
            var maxY = Math.max(fromNode.y, toNode.y);
            if (maxX < viewLeft || minX > viewRight || maxY < viewTop || minY > viewBottom) return null;

            return { fromNode: fromNode, toNode: toNode };
        }

        // Center → root lines
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];
            if (!node.isRoot) continue;
            if (typeof settings !== 'undefined' && settings.schoolVisibility && settings.schoolVisibility[node.school] === false) continue;

            var isOnLP = this._learningPathNodes instanceof Set && this._learningPathNodes.has(node.id);
            if (isOnLP && this._animatingPathNodes && this._animatingPathNodes.has(node.id)) isOnLP = false;
            if (node.state !== 'unlocked' && !isOnLP) continue;

            var isRootOnSP = this._selectedPathNodes && this._selectedPathNodes.has(node.id);
            var showSP = typeof settings !== 'undefined' ? settings.showSelectionPath !== false : true;

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(node.x, node.y);

            if (isOnLP) {
                ctx.strokeStyle = learningPathColor;
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.7;
            } else if (isRootOnSP && showSP) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.45;
            } else if (hasSelectedPath && showSP) {
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.08;
            } else {
                ctx.strokeStyle = this._getSchoolColor(node.school);
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4;
            }
            ctx.stroke();
        }

        // Pass 1: Base edges
        var showBase = typeof settings === 'undefined' || settings.showBaseConnections !== false;
        ctx.lineWidth = 1;

        for (var i = 0; i < this.edges.length; i++) {
            var edge = this.edges[i];
            var pair = shouldDrawEdge(edge);
            if (!pair) continue;

            var edgeKey = edge.from + '->' + edge.to;
            var isOnSP = this._selectedPathEdges && this._selectedPathEdges.has(edgeKey);
            var fromOnLP = hasLearningPaths && this._learningPathNodes.has(pair.fromNode.id);
            var toOnLP = hasLearningPaths && this._learningPathNodes.has(pair.toNode.id);
            if (isOnSP || (fromOnLP && toOnLP)) continue;

            var bothUnlocked = pair.fromNode.state === 'unlocked' && pair.toNode.state === 'unlocked';
            if (!bothUnlocked && !showBase) continue;

            var showSPDim = typeof settings === 'undefined' || settings.showSelectionPath !== false;

            if (hasSelectedPath && showSPDim) {
                ctx.strokeStyle = '#222';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.08;
            } else if (bothUnlocked) {
                ctx.strokeStyle = this._getSchoolColor(pair.fromNode.school);
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
            } else {
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.15;
            }

            ctx.beginPath();
            ctx.moveTo(pair.fromNode.x, pair.fromNode.y);
            ctx.lineTo(pair.toNode.x, pair.toNode.y);
            ctx.stroke();
        }

        // Pass 2: Selected path edges
        var showSP2 = typeof settings === 'undefined' || settings.showSelectionPath !== false;
        if (hasSelectedPath && showSP2) {
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                var pair = shouldDrawEdge(edge);
                if (!pair) continue;
                var edgeKey = edge.from + '->' + edge.to;
                if (!this._selectedPathEdges.has(edgeKey)) continue;
                var fromOnLP = hasLearningPaths && this._learningPathNodes.has(pair.fromNode.id);
                var toOnLP = hasLearningPaths && this._learningPathNodes.has(pair.toNode.id);
                if (fromOnLP && toOnLP) continue;

                ctx.strokeStyle = '#555555';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.5;
                ctx.beginPath();
                ctx.moveTo(pair.fromNode.x, pair.fromNode.y);
                ctx.lineTo(pair.toNode.x, pair.toNode.y);
                ctx.stroke();
            }
        }

        // Pass 3: Learning path edges
        if (hasLearningPaths) {
            for (var i = 0; i < this.edges.length; i++) {
                var edge = this.edges[i];
                var pair = shouldDrawEdge(edge);
                if (!pair) continue;
                var fromOnLP = this._learningPathNodes.has(pair.fromNode.id);
                var toOnLP = this._learningPathNodes.has(pair.toNode.id);
                if (!fromOnLP || !toOnLP) continue;
                if (this._animatingPathNodes && this._animatingPathNodes.has(pair.fromNode.id) && this._animatingPathNodes.has(pair.toNode.id)) continue;

                ctx.strokeStyle = learningPathColor;
                ctx.lineWidth = pair.toNode.state === 'learning' ? 3 : 2;
                ctx.globalAlpha = 0.7;
                ctx.beginPath();
                ctx.moveTo(pair.fromNode.x, pair.fromNode.y);
                ctx.lineTo(pair.toNode.x, pair.toNode.y);
                ctx.stroke();
            }
        }

        ctx.globalAlpha = 1.0;
    },

    // =========================================================================
    // LEARNING PATH ANIMATION
    // =========================================================================

    _renderLearningPathAnimation: function(ctx) {
        if (!this._learningPath) return;

        var lp = this._learningPath;
        var elapsed = performance.now() - lp.startTime;
        var progress = Math.min(elapsed / this._learningPathDuration, 1);
        var easedProgress = 1 - Math.pow(1 - progress, 2);

        var path = lp.path;
        if (path.length < 2) return;

        var totalLength = 0;
        var segmentLengths = [];
        for (var i = 1; i < path.length; i++) {
            var dx = path[i].x - path[i - 1].x;
            var dy = path[i].y - path[i - 1].y;
            var len = Math.sqrt(dx * dx + dy * dy);
            segmentLengths.push(len);
            totalLength += len;
        }

        var targetLength = totalLength * easedProgress;

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(path[0].x, path[0].y);

        var drawnLength = 0;
        for (var i = 1; i < path.length; i++) {
            var segLen = segmentLengths[i - 1];
            if (drawnLength + segLen <= targetLength) {
                ctx.lineTo(path[i].x, path[i].y);
                drawnLength += segLen;
            } else {
                var remaining = targetLength - drawnLength;
                var t = remaining / segLen;
                ctx.lineTo(
                    path[i - 1].x + (path[i].x - path[i - 1].x) * t,
                    path[i - 1].y + (path[i].y - path[i - 1].y) * t
                );
                break;
            }
        }

        ctx.strokeStyle = this._learningPathColor || '#00ffff';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        ctx.restore();

        if (progress >= 1) {
            this._learningPathAnimationComplete = true;
            this._animatingPathNodes = null;
            if (elapsed > this._learningPathDuration + 200) {
                this._learningPath = null;
            }
        }

        if (this._learningPath) {
            this._needsRender = true;
            this._animationOnlyRender = true;
        }
    },

    // =========================================================================
    // NODE RENDERING (tier-differentiated with state modulation)
    // =========================================================================

    _renderNodes: function(ctx, viewLeft, viewRight, viewTop, viewBottom) {
        for (var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];

            // Viewport culling
            if (node.x < viewLeft || node.x > viewRight || node.y < viewTop || node.y > viewBottom) continue;

            // School visibility
            if (typeof settings !== 'undefined' && settings.schoolVisibility && settings.schoolVisibility[node.school] === false) continue;

            // Discovery mode
            if (this._discoveryVisibleIds && !(typeof EditMode !== 'undefined' && EditMode.isActive)) {
                if (!this._discoveryVisibleIds.has(node.id) && !this._discoveryVisibleIds.has(node.formId)) continue;
                if (node.state === 'locked') {
                    this._renderMysteryNode(ctx, node);
                    continue;
                }
            }

            this._renderNode(ctx, node);
        }
    },

    _renderNode: function(ctx, node) {
        var schoolColor = this._getSchoolColor(node.school);
        var isSelected = this.selectedNode && this.selectedNode.id === node.id;
        var isHovered = this.hoveredNode && this.hoveredNode.id === node.id;
        var learningPathColor = this._learningPathColor || '#00ffff';
        var ringColor = this._heartRingColor || '#b8a878';

        var isOnLP = (this._learningPathNodes instanceof Set) && this._learningPathNodes.has(node.id);
        var isLearning = (node.state === 'learning' || node.state === 'Learning');
        var isBeingAnimated = this._animatingPathNodes && this._animatingPathNodes.has(node.id);
        if (isOnLP && isBeingAnimated) isOnLP = false;
        var showLearningStyle = isLearning && !isBeingAnimated;

        // Determine base size and alpha from state
        var skillLevel = node.skillLevel || node.level || 'Apprentice';
        var tierMult = TierVisuals.getSize(skillLevel);
        var tierBright = TierVisuals.getBrightness(skillLevel);

        var baseSize, baseAlpha, fillColor, strokeColor, strokeWidth;

        if (node.state === 'unlocked') {
            baseSize = 8;
            baseAlpha = 1.0;
            fillColor = schoolColor;
            strokeColor = isOnLP ? ringColor : schoolColor;
            strokeWidth = 1.5;
        } else if (showLearningStyle) {
            baseSize = 8;
            baseAlpha = 1.0;
            fillColor = learningPathColor;
            strokeColor = ringColor;
            strokeWidth = 1.5;
        } else if (node.state === 'available' || (isLearning && isBeingAnimated)) {
            baseSize = 6;
            baseAlpha = 0.8;
            fillColor = '#1a1a2e';
            strokeColor = schoolColor;
            strokeWidth = 1;
        } else {
            // locked / default
            baseSize = 5;
            baseAlpha = 0.4;
            fillColor = '#1a1a2e';
            strokeColor = schoolColor;
            strokeWidth = 1;
        }

        var size = baseSize * tierMult;
        var alpha = baseAlpha * Math.min(Math.max(tierBright, 0.3), 1.2);

        if (isSelected || isHovered) {
            size += 1.5;
            strokeColor = '#fff';
            strokeWidth = 1.5;
            alpha = 1.0;
        }

        ctx.save();
        ctx.globalAlpha = alpha;

        // Glow
        ctx.fillStyle = TierVisuals._hexToRgba(fillColor, alpha * 0.15);
        TierVisuals._fillShape(ctx, skillLevel, node.x, node.y, size + 3);

        // Body
        ctx.fillStyle = fillColor;
        TierVisuals._fillShape(ctx, skillLevel, node.x, node.y, size);

        // Expert double border
        if (skillLevel === 'Expert') {
            ctx.strokeStyle = TierVisuals._hexToRgba(strokeColor, alpha * 0.5);
            ctx.lineWidth = 1.0;
            TierVisuals._strokeShape(ctx, skillLevel, node.x, node.y, size + 1.5);
        }

        // Master glow ring
        if (skillLevel === 'Master') {
            ctx.beginPath();
            ctx.arc(node.x, node.y, size + 4, 0, Math.PI * 2);
            ctx.strokeStyle = TierVisuals._hexToRgba(strokeColor, alpha * 0.35);
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // Border
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = strokeWidth;
        TierVisuals._strokeShape(ctx, skillLevel, node.x, node.y, size);

        // Unlocked inner accent
        if (node.state === 'unlocked') {
            var innerSize = size * 0.5;
            ctx.fillStyle = TierVisuals.getInnerAccentColor(schoolColor);
            TierVisuals._fillShape(ctx, skillLevel, node.x, node.y, innerSize);
        }

        // Learning white center dot
        if (isLearning && !isBeingAnimated) {
            var dotSize = size * 0.3;
            ctx.fillStyle = '#ffffff';
            TierVisuals._fillShape(ctx, skillLevel, node.x, node.y, dotSize);
        }

        // Root marker
        if (node.isRoot) {
            TierVisuals.renderRootMarker(ctx, node.x, node.y, schoolColor, size);
        }

        ctx.restore();
        ctx.globalAlpha = 1.0;
    },

    _renderMysteryNode: function(ctx, node) {
        var color = this._getSchoolColor(node.school);
        var dimmed = TierVisuals.dimColor(color, 0.4);
        var size = 8;

        ctx.save();
        ctx.translate(node.x, node.y);

        ctx.fillStyle = 'rgba(20, 20, 30, 0.9)';
        ctx.strokeStyle = dimmed;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.6;

        // Simple circle for mystery nodes (no per-school shapes)
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // Question mark
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = dimmed;
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('?', 0, 0);

        ctx.restore();
        ctx.globalAlpha = 1.0;
    },

    // =========================================================================
    // HEARTBEAT HUB
    // =========================================================================

    _renderHub: function(ctx) {
        var pulse = 0;
        var scale = 1;

        if (this._heartAnimationEnabled) {
            this._heartbeatPhase += this._heartbeatSpeed;
            var phasePerSecond = this._heartbeatSpeed * 60;
            var pulseDelay = (this._heartPulseDelay || 2.0) * phasePerSecond;
            var beatDuration = Math.PI;
            var cycleLength = beatDuration + pulseDelay;
            var cyclePos = this._heartbeatPhase % cycleLength;

            if (cyclePos < beatDuration) {
                var beat1 = Math.max(0, Math.sin(cyclePos * 2));
                var beat2 = Math.max(0, Math.sin(cyclePos * 2 - 0.8));
                pulse = (beat1 + beat2 * 0.6) * 0.08;
            }
            scale = 1 + pulse;
        }

        var globeEnabled = this._globeEnabled && (typeof Globe3D !== 'undefined') && Globe3D.enabled;
        if (this._heartAnimationEnabled || globeEnabled) {
            this._needsRender = true;
            this._animationOnlyRender = true;
        }

        ctx.save();
        ctx.scale(scale, scale);

        var baseRadius = 45;
        var ringColor = this._heartRingColor || '#b8a878';
        var bgColor = this._heartBgColor || '#000000';
        var bgOpacity = this._heartBgOpacity !== undefined ? this._heartBgOpacity : 1.0;

        var ringRgb = TierVisuals.parseColor(ringColor);
        var glowColor = ringRgb ? 'rgba(' + ringRgb.r + ',' + ringRgb.g + ',' + ringRgb.b + ',' : 'rgba(184, 168, 120, ';

        // Outer glow
        var glowAlpha = 0.15 + pulse * 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius + 8, 0, Math.PI * 2);
        ctx.fillStyle = glowColor + glowAlpha + ')';
        ctx.fill();

        // Background
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
        ctx.globalAlpha = bgOpacity;
        ctx.fillStyle = bgColor;
        ctx.fill();
        ctx.globalAlpha = 1.0;

        // Inner decorative ring
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius - 5, 0, Math.PI * 2);
        ctx.strokeStyle = glowColor + '0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Outer border
        ctx.beginPath();
        ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
        ctx.strokeStyle = ringColor;
        ctx.lineWidth = 2.5;
        ctx.stroke();

        // Text
        var textColor = this._magicTextColor || ringColor;
        var fontSize = this._globeTextSize || 16;
        var globeText = this._globeText || 'HoM';
        ctx.fillStyle = textColor;
        ctx.font = 'bold ' + fontSize + 'px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        var lines = globeText.replace(/\\n/g, '\n').split('\n');
        var lineHeight = fontSize * 1.2;
        var totalHeight = (lines.length - 1) * lineHeight;
        var startY = -totalHeight / 2;
        for (var i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], 0, startY + i * lineHeight);
        }

        // Globe 3D
        if (this._globeEnabled && typeof Globe3D !== 'undefined') {
            Globe3D.setColor(this._globeColor || ringColor);
            Globe3D.render(ctx);
        }

        ctx.restore();
    },

    // =========================================================================
    // LABELS (screen-aligned)
    // =========================================================================

    _renderLabels: function(ctx, cx, cy) {
        if (this.zoom < 0.6) return;

        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        var labelsDrawn = 0;
        var maxLabels = 150;

        for (var i = 0; i < this.nodes.length && labelsDrawn < maxLabels; i++) {
            var node = this.nodes[i];
            var isEditActive = typeof EditMode !== 'undefined' && EditMode.isActive;

            if (!isEditActive && node.state !== 'unlocked' && node.state !== 'learning' && node.state !== 'available') continue;
            if (!node.name && !isEditActive) continue;
            if (typeof settings !== 'undefined' && settings.schoolVisibility && settings.schoolVisibility[node.school] === false) continue;

            var labelText = node.name || node.formId;
            if (!isEditActive && node.state !== 'unlocked' && (typeof settings === 'undefined' || settings.cheatMode !== true)) {
                var _canonId = (typeof getCanonicalFormId === 'function') ? getCanonicalFormId(node) : node.formId;
                var _prog = (typeof state !== 'undefined' && state.spellProgress) ? state.spellProgress[_canonId] : null;
                var _pct = _prog && _prog.required > 0 ? (_prog.xp / _prog.required) * 100 : 0;
                var _threshold = (typeof settings !== 'undefined' && settings.revealName !== undefined) ? settings.revealName : 10;
                if (_pct < _threshold && node.state !== 'learning') {
                    labelText = '???';
                }
            }

            if (node.state === 'unlocked') {
                ctx.fillStyle = '#fff';
            } else if (node.state === 'learning') {
                ctx.fillStyle = this._learningPathColor || '#00ffff';
            } else if (labelText === '???') {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            }

            var screenX = node.x * this.zoom + this.panX + cx;
            var screenY = node.y * this.zoom + this.panY + cy;

            if (screenX < -50 || screenX > this._width + 50 || screenY < -50 || screenY > this._height + 50) continue;

            ctx.fillText(labelText.substring(0, 12), screenX, screenY + 14 * this.zoom);
            labelsDrawn++;
        }
    },

    // =========================================================================
    // TOOLTIP
    // =========================================================================

    _showTooltip: function(node, event) {
        if (!this._tooltipEl) {
            this._tooltipEl = document.createElement('div');
            this._tooltipEl.className = 'spell-tooltip';
            this._tooltipEl.style.cssText = 'position: fixed; pointer-events: none; z-index: 1000; ' +
                'background: rgba(10,10,20,0.95); color: #fff; padding: 8px 12px; border-radius: 6px; ' +
                'font-size: 12px; border: 1px solid rgba(255,255,255,0.15); max-width: 250px; ' +
                'box-shadow: 0 4px 12px rgba(0,0,0,0.5);';
            document.body.appendChild(this._tooltipEl);
        }

        var name = node.name || node.formId || '???';
        var school = node.school || '';
        var tier = node.skillLevel || node.level || '';
        var stateText = node.state || 'locked';

        var color = this._getSchoolColor(school);
        var html = '<div style="font-weight:bold; color:' + color + ';">' + name + '</div>';
        html += '<div style="opacity:0.7; margin-top:2px;">' + school + (tier ? ' &middot; ' + tier : '') + '</div>';
        html += '<div style="opacity:0.5; margin-top:2px;">' + stateText + '</div>';

        this._tooltipEl.innerHTML = html;
        this._tooltipEl.style.display = 'block';
        this._tooltipEl.style.left = (event.clientX + 12) + 'px';
        this._tooltipEl.style.top = (event.clientY + 12) + 'px';
    },

    _hideTooltip: function() {
        if (this._tooltipEl) {
            this._tooltipEl.style.display = 'none';
        }
    },

    // =========================================================================
    // FALLBACK SPIRAL LAYOUT
    // =========================================================================

    _applyFallbackSpiral: function() {
        var schoolGroups = {};
        for (var i = 0; i < this.nodes.length; i++) {
            var school = this.nodes[i].school || 'Unknown';
            if (!schoolGroups[school]) schoolGroups[school] = [];
            schoolGroups[school].push(this.nodes[i]);
        }

        var schoolNames = Object.keys(schoolGroups);
        var nSchools = schoolNames.length || 1;
        var spacing = 40;

        for (var si = 0; si < schoolNames.length; si++) {
            var group = schoolGroups[schoolNames[si]];
            var baseAngle = (si / nSchools) * Math.PI * 2;

            for (var ni = 0; ni < group.length; ni++) {
                var depth = ni + 1;
                var radius = spacing * depth;
                var angle = baseAngle + depth * 0.3;
                group[ni].x = Math.cos(angle) * radius;
                group[ni].y = Math.sin(angle) * radius;
            }
        }
        console.log('[SpellTreeRenderer] Fallback spiral applied to', this.nodes.length, 'nodes');
    },

    // =========================================================================
    // PUBLIC API (matches CanvasRenderer for compatibility)
    // =========================================================================

    show: function() {
        if (!this.canvas || !this.container) {
            console.error('[SpellTreeRenderer] Cannot show - not initialized');
            return;
        }

        var svg = document.getElementById('tree-svg');
        if (svg) svg.style.display = 'none';

        if (!this.canvas.parentNode) {
            this.container.appendChild(this.canvas);
        }

        this.updateCanvasSize();
        this.startRenderLoop();
        this.forceRender();

        var self = this;
        setTimeout(function() { self.updateCanvasSize(); }, 100);

        console.log('[SpellTreeRenderer] Shown with', this.nodes.length, 'nodes');
    },

    hide: function() {
        this.stopRenderLoop();
        if (this._resizeTimeout) {
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = null;
        }
        if (this.canvas && this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        this._hideTooltip();
        var svg = document.getElementById('tree-svg');
        if (svg) svg.style.display = 'block';
    },

    centerView: function() {
        this.panX = 0;
        this.panY = 0;
        this.zoom = 0.75;
        this._needsRender = true;
        var zoomEl = document.getElementById('zoom-level');
        if (zoomEl) zoomEl.textContent = Math.round(this.zoom * 100) + '%';
    },

    setZoom: function(z) {
        this.zoom = Math.max(0.1, Math.min(5, z));
        this._needsRender = true;
        var zoomEl = document.getElementById('zoom-level');
        if (zoomEl) zoomEl.textContent = Math.round(this.zoom * 100) + '%';
    },

    clear: function() {
        this.nodes = [];
        this.edges = [];
        this.schools = {};
        this._nodeMap = new Map();
        this._nodeByFormId = new Map();
        this._nodeGrid = {};
        this._discoveryVisibleIds = null;
        this.selectedNode = null;
        this.hoveredNode = null;
        this._selectedPathEdges = null;
        this._selectedPathNodes = null;

        if (this.ctx && this.canvas) {
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        this._needsRender = true;
    },

    refresh: function() {
        this._buildDiscoveryVisibility();
        this._buildLearningPaths();
        this._needsRender = true;
    },

    toggleDebugGrid: function() {
        this.showDebugGrid = !this.showDebugGrid;
        this._needsRender = true;
        return this.showDebugGrid;
    },

    // Rotation stubs (no rotation in SpellTreeRenderer, but API compatible)
    rotateToNode: function() {},
    rotateSchoolToTop: function() {},
    animateRotation: function() {},

    // Expose onNodeClick as public API for external handlers
    onNodeClick: null
};

// =========================================================================
// EditMode compatibility: Alias CanvasRenderer → SpellTreeRenderer
// EditMode references CanvasRenderer by name (~100 times). This alias
// makes all EditMode operations (drag nodes, draw/erase edges, undo)
// work transparently on SpellTreeRenderer's data.
// =========================================================================
if (typeof CanvasRenderer !== 'undefined') {
    // Preserve a reference to the old renderer in case it's needed
    window._LegacyCanvasRenderer = CanvasRenderer;
}
// Override the global CanvasRenderer to be SpellTreeRenderer
window.CanvasRenderer = SpellTreeRenderer;

console.log('[SpellTreeRenderer] Loaded (CanvasRenderer aliased)');
